# 渲染引擎
本项目采用bgfx作为渲染底库实现跨平台渲染
## 内置物体
内置物体：立方体、长方体、球体、胶囊体、圆柱体、天空盒
## 组件支持
### Camera
用于控制场景中相机的视角和投影方式。它可以设置相机的位置、旋转、视野、投影方式等参数。
### Light
用于在场景中创建光源。它可以设置光源的颜色、强度、类型、范围等参数。
### Light Probe Group
用于在场景中创建光探针组。它可以用于实现动态物体的光照计算，增强游戏的真实感和逼真度。
### Light Probe Proxy Volume
用于在场景中创建光探针代理体。
Light Probe Proxy Volume可以在场景中创建一个代理体，用于计算物体的光照效果。
它可以设置代理体的大小、分辨率、光照范围等参数。在运行时，代理体会根据物体的位置和角度计算出物体的光照效果，从而达到真实的光照效果。
区别：Light Probe Group可以设置光探针的位置、光照范围、采样数量等参数，而Light Probe Proxy Volume可以设置代理体的大小、分辨率、光照范围等参数。Light Probe Group适用于需要在场景中创建多个光探针的情况，例如室内场景、战斗场景等，而Light Probe Proxy Volume适用于需要在场景中创建一个代理体的情况，例如大型开放世界游戏、城市场景等。
### Reflection Probe
用于在场景中创建反射探针。它可以用于实现动态物体的反射效果，增强游戏的真实感和逼真度。
### Occlusion Area
用于创建遮挡区域。它可以用于优化游戏的性能，减少不必要的渲染工作量。
### Occlusion Portal
用于创建遮挡门。一些区域可能会有多个出入口或者门，开门时渲染，关门时剔除。
### LOD Group
用于控制物体的LOD（Level of Detail）级别。它可以用于优化游戏的性能，减少不必要的渲染工作量。
在游戏中，一些物体可能有不同的LOD级别，即根据物体距离玩家的远近，使用不同的模型或者材质来渲染。这可以提高游戏的性能，减少不必要的渲染工作量。
通过使用LOD Group组件，可以很方便地控制物体的LOD级别。
### Canvas Renderer
用于将UI元素渲染到屏幕上。它可以用于创建各种UI元素，例如按钮、文本框、图片等。
### Sprite Renderer
用于将2D精灵渲染到屏幕上。它可以用于创建2D游戏中的角色、背景、道具等元素。
### Flare Layer
用于创建游戏场景中的光晕效果。它可以用于创建各种不同的光晕效果，例如太阳光芒、灯光折射等。
### Tilemap
用于创建2D游戏场景中的地图。它可以用于创建各种不同的地图，例如平面地图、迷宫地图、战斗地图等。
### Tilemap Renderer
用于渲染2D游戏场景中的Tilemap。它可以用于将Tilemap渲染到游戏场景中，让玩家可以看到真实的地图效果。
### Tilemap Collider 2D
用于为2D游戏场景中的Tilemap添加碰撞体。它可以用于处理角色、物体和地图之间的碰撞关系，让游戏更加真实。
### Event Collector
用于处理用户交互事件。它可以用于捕捉用户的输入、点击、拖拽等事件，并将其发送给合适的游戏对象进行处理。
### Physics Raycaster
用于在3D场景或2D场景中进行物理射线检测。它可以用于检测鼠标点击、触摸屏幕等事件，并获取被点击的物体或碰撞点等信息。
### Standalone Input Module
用于处理鼠标、键盘等输入设备的输入事件。它可以用于捕捉用户在游戏中的输入事件，并将其转换成本引擎中的事件系统。
### Transform
用于控制物体的位置、旋转和缩放等变换操作。它是所有物体的基础组件之一，可以实现物体的移动、旋转和缩放等操作。
### MeshDescriptor
用于将网格数据应用到 3D 模型上。它是实现 3D 模型的重要组成部分之一，可以定义模型的形状和结构。
MeshDescriptor 可以将网格数据应用到 3D 模型上，从而定义模型的形状和结构。
它通过读取网格数据，包括顶点、三角形面片等信息，来定义模型的形状和结构。
这些网格数据可以通过外部工具（例如 Blender、Maya 等）创建，也可以通过代码动态生成。
### Text Mesh
用于将文本转换为 3D 网格，以便进行高效的渲染和交互。
Text Mesh 可以用来渲染各种文本内容，例如游戏中的标签、计分板、物品名称等等。
它能够将文本转换为 3D 网格，并使用 GPU 进行加速渲染，从而能够高效地处理大量文本内容。
### Capsule Collider
用于将游戏对象转换为一个胶囊形状的物理碰撞体。
Capsule Collider 可以与刚体组件一起使用，以便让游戏对象能够受到外力的作用，并且可以与其他类型的碰撞体进行碰撞检测。
### Mesh Collider
用于将游戏对象的 Mesh 网格转换为物理碰撞体，以便在游戏中进行物理交互。
Mesh Collider 可以与刚体组件一起使用，以便让游戏对象能够受到外力的作用，并且可以与其他 Mesh Collider 或其他类型的碰撞体进行碰撞检测。
### Terrain Collider
用于在场景中的地形（Terrain）上添加碰撞检测功能。
当一个物体与Terrain Collider发生接触时，就会触发碰撞事件，从而可以实现各种游戏场景的交互效果。
它基于地形的高度图和纹理信息，自动生成一个准确的碰撞器，从而实现真实的碰撞检测效果。
### Wheel Collider
用于模拟车辆的轮胎碰撞效果。它可以将车辆的轮胎与地面进行真实的碰撞检测，从而实现车辆的运动效果。
当一个车辆游戏对象上添加了Wheel Collider组件后，该组件会自动根据车轮的位置和半径生成一个碰撞器。
车辆在运动过程中，Wheel Collider会根据车轮的旋转情况和与地面的接触情况，计算出车轮的运动状态，包括速度、加速度、阻力等，并将这些信息反馈给车辆游戏对象，从而实现真实的车辆运动效果。
### Fixed Joint
用于将两个游戏对象固定在一起，从而实现刚体之间的约束。它可以模拟物理学中的刚体连接效果，使得两个游戏对象的运动状态相互影响。
Fixed Joint通常用于模拟各种机械装置、建筑物结构等，例如门、桥梁、吊车等。
当两个游戏对象之间添加了Fixed Joint组件后，它们就会被连接在一起，从而形成一个整体。在运动过程中，它们的位置和旋转状态会相互影响，从而实现真实的物理效果。
### Spring Joint 2D
用于模拟弹簧的力学效应，使得两个游戏对象之间产生弹簧效果。
它可以模拟物理学中的弹簧连接效果，使得两个游戏对象之间产生拉扯的力量。
Spring Joint 2D通常用于模拟各种弹簧装置、弹性物体等，例如弹簧床、绳索、弹性球等。
当两个游戏对象之间添加了Spring Joint 2D组件后，它们就会被连接在一起，从而形成一个弹簧。在运动过程中，它们之间的距离和速度会相互影响，从而产生弹簧效果。
### Friction Joint 2D
用于模拟两个游戏对象之间的摩擦力效果，使得它们之间的运动产生摩擦力。它可以模拟物理学中的摩擦效应，使得两个游戏对象之间的运动更加真实。
### Distance Joint 2D
用于模拟两个游戏对象之间的距离约束，使得它们之间的距离保持不变。它可以模拟物理学中的距离效应，使得两个游戏对象之间的运动产生约束。
### Target Joint 2D
用于模拟物体的跟踪效果，使得一个游戏对象能够跟随另一个游戏对象的运动轨迹。它可以模拟物理学中的跟踪效应，使得游戏对象之间的运动更加真实。
### Hinge Joint 2D
用于模拟物体的旋转效果，使得两个游戏对象之间产生旋转约束。它可以模拟物理学中的旋转效应，使得两个游戏对象之间的运动更加真实。
Hinge Joint 2D通常用于模拟各种旋转装置、旋转门等，例如旋转门、旋转关节等。
### Wheel Joint 2D
用于模拟车轮的旋转效果，使得一个游戏对象能够沿着一个轮轴线移动。它可以模拟物理学中的车轮运动，使得游戏对象之间的运动更加真实。
### Relative Joint 2D
用于将两个物体连接在一起，使它们相对运动。与其他关节组件不同，Relative Joint 2D允许开发者指定相对移动向量，而不是像其他关节组件一样强制物体在特定方向上移动。
### Slider Joint 2D
用于将两个物体连接在一起，并允许它们在特定方向上相对移动。Slider Joint 2D通常被用于创建滑动门、升降机等物体，以及各种游戏对象之间的连接。
### Articulation Body
用于创建复杂的物理模拟效果。它可以将物体分解成多个部分，每个部分都有自己的物理属性和关节，使得物体在运动和碰撞时更加真实和可控。
### Nav Mesh Agent
用于实现游戏对象的导航功能。Nav Mesh Agent通常用于模拟各种导航效果，例如角色移动、AI行为等。
### Nav Mesh Obstacle
用于在场景中创建动态障碍物，以影响Nav Mesh Agent的自动导航行为。
Nav Mesh Obstacle可以让开发者在运行时添加或移除障碍物，从而实现更加灵活的导航功能。
### Off Mesh Link
用于在导航网格上创建离散的连接点，以实现Nav Mesh Agent之间跨越障碍物或空隙的导航。
通常，在场景中出现的一些特殊情况，例如悬崖、吊桥、绳索等，需要Nav Mesh Agent能够跨越障碍物进行导航，这时就需要用到Off Mesh Link。
### Audio Source
用于在场景中播放音频。开发者可以将Audio Source组件添加到游戏对象上，并将音频文件添加到Audio Source组件中进行播放。
### Audio Listener
用于监听场景中的音频，并将其转换为可听的声音。每个场景中只能有一个Audio Listener，它通常被添加到主摄像机上，以便根据摄像机位置和方向来监听音频。
当Audio Listener接收到音频时，它会根据音频源的位置、方向和距离等信息，将音频转换为可听的声音，并将其输出到扬声器或耳机中。
Audio Listener还支持3D音效，可以根据音频源的位置和距离等信息，产生方向和距离的变化，从而增强游戏的真实感和沉浸感。
### Audio Reverb Zone
用于模拟音频的混响效果。它可以将场景中的音频信号经过处理，产生类似于在一个封闭空间中听到声音的效果。
在游戏中，Audio Reverb Zone通常被用于模拟不同环境下的声音效果，例如室内、室外、山洞等。
### Audio Low Pass Filter
用于控制音频的低频信号。它可以通过降低音频的低频信号来模拟不同的音效，使得音频更加真实。
Audio Low Pass Filter通常用于模拟各种音效，例如低沉的嗓音、远处的声音等。
当一个音频源添加了Audio Low Pass Filter组件后，它就会对音频进行低频信号过滤，从而模拟不同的音效。
### Audio High Pass Filter
用于控制音频的高频信号。它可以通过降低音频的高频信号来模拟不同的音效，使得音频更加真实。
Audio High Pass Filter通常用于模拟各种音效，例如尖锐的声音、近处的声音等。
当一个音频源添加了Audio High Pass Filter组件后，它就会对音频进行高频信号过滤，从而模拟不同的音效。
### Audio Echo Filter
用于在音频中加入回声效果。它可以模拟不同的回声效果，使得音频更加真实。
Audio Echo Filter通常用于模拟各种音效，例如在山洞或大厅中的声音回声。
当一个音频源添加了Audio Echo Filter组件后，它就会对音频进行回声处理，从而模拟不同的回声效果。
### Audio Distortion Filter
用于在音频中加入失真效果。它可以模拟各种失真效果，使得音频更加独特。
Audio Distortion Filter通常用于模拟各种音效，例如吉他失真效果、电子音乐等。
当一个音频源添加了Audio Distortion Filter组件后，它就会对音频进行失真处理，从而模拟不同的失真效果。
### Audio Chorus Filter
用于在音频中添加合唱效果。合唱效果是指将多个声音混合在一起，产生更加丰富、立体的音效。
Audio Chorus Filter通过改变音频的时间和频率，来模拟多个声音同时发生的效果。
它包含多个参数，例如混响、延迟、振幅等，可以用来调整合唱效果的强度、深度和速度等。
### Particle Effect
用于创建和控制粒子效果。例如火花、烟雾、水滴等，可以用来增强游戏的视觉效果和氛围。
Particle Effect包含多个参数，例如粒子的形状、大小、速度、颜色等，可以用来调整粒子效果的外观和行为。
同时，还支持多种粒子发射方式，例如喷射、爆炸、旋转等，可以让粒子效果更加生动、多样。
### Visual Effect
用于创建和控制各种视觉效果。Visual Effect使用基于节点的图形编辑器，可以用来创建复杂的视觉效果，例如火焰、水、云等。
Visual Effect包含多个节点，每个节点代表一个图形特效。
节点可以用来控制特效的外观、行为和运动方式。Visual Effect还支持多种渲染技术，例如体积渲染、屏幕空间反射等，可以用来增强特效的真实感和逼真度。
### Trail Renderer
用于创建和控制轨迹效果。轨迹效果是指物体在移动过程中留下的痕迹，例如火箭尾迹、手指滑动的轨迹等。
Trail Renderer可以将物体的移动轨迹以一定的精度绘制出来，并用材质渲染出来。它包含多个参数，例如宽度、颜色、持续时间等，可以用来调整轨迹效果的外观和行为。
### Line Renderer
用于创建和控制线条效果。线条效果是指一些简单的、连续的、直线或曲线形状的图形元素，例如绘画、图表、游戏中的路径等。
Line Renderer可以将一组点连接起来，以一定的精度绘制出线条，可以用材质渲染出来。它包含多个参数，例如宽度、颜色、连接方式等，可以用来调整线条效果的外观和行为。
### Projector
用于在场景中投影纹理。它可以将一个纹理投影到场景中的任何一个物体上，以模拟阴影、反射、环境光、景深等效果。
Projector可以设置投影的纹理、角度、位置、大小、透明度等参数。它也可以用于动态投影，例如在游戏中实时投射玩家的角色影像。
### Lens Flare
用于在游戏中模拟相机镜头中的Lens Flare效果。
Lens Flare可以设置光晕的类型、大小、亮度、色彩、位置等参数。它可以用来模拟太阳、月亮、灯光等光源的光晕效果。
### Halo
用于在游戏中创建光晕效果。它可以在相机的视野中为物体创建一个光晕，以模拟物体周围的光线反射和扩散效果。
Halo可以设置光晕的大小、颜色、强度、扩散方式等参数。它可以用于创建各种光晕效果，例如太阳、月亮、灯光等。
### Particle Effect Force Field
它可以在场景中创建一个力场，通过吸引或排斥粒子来实现各种效果。使用Particle Effect Force Field可以创建各种复杂的粒子效果，如火焰、水流、爆炸等。
### Wind Zone
它可以在场景中创建一个风区域，通过改变风的方向、速度和扰动等参数，来模拟各种不同的风效果。
Wind Zone提供了许多属性和方法，如风的方向、风的速度、风的扰动、风的最大距离等，使开发人员可以轻松地创建和管理风效果。
它还可以与其他组件配合使用，如Rigidbody、Cloth、Particle Effect等。
### Playable Director
用于控制时间线（Timeline）。它可以帮助开发人员创建复杂的场景、剧情、动画和游戏流程，并在运行时播放和控制它们。
### Animator
使用Animator可以创建各种动画效果，如行走、跑步、跳跃、攻击等，增强游戏的视觉效果和互动性。它可以帮助开发人员创建更加复杂和有趣的游戏，让玩家更加享受游戏。
### Terrain
Terrain可以通过高度图、纹理贴图、细节图等方式创建地形效果，并支持地形的平滑、粗糙、高低等各种属性设置。它还可以添加各种地形元素，如草、树木、岩石等，使地形更加真实和生动。
### Billboard Renderer
它可以将3D对象渲染成2D图像，使其在摄像机视野内保持始终朝向摄像机的效果。在游戏中，当玩家移动摄像机时，该组件可以确保物体的朝向始终与摄像机相同。
### Sprite Shape Renderer
它可以创建基于网格的2D形状，并为其应用纹理和材质。使用Sprite Shape Renderer可以创建各种2D形状，如圆形、矩形、多边形等，并可以使用Sprite Renderer或Tilemap Renderer来渲染这些形状。
### Sprite Mask
它可以将2D精灵遮罩，以创建各种视觉效果。使用Sprite Mask可以创建各种遮罩，如圆形、矩形、多边形等，并可以将其应用于2D精灵、UI元素和文本等。
